# ä¸“åˆ©æ–‡ä»¶ä¸Šä¼ æ¡Œé¢åº”ç”¨ - å®Œæ•´è®¾è®¡æ–¹æ¡ˆ

## ğŸ“‹ é¡¹ç›®æ¦‚è¿°

æœ¬é¡¹ç›®æ˜¯ä¸€ä¸ªåŸºäº Tauri + Vue3 + TypeScript å¼€å‘çš„æ¡Œé¢åº”ç”¨ç¨‹åºï¼Œä¸»è¦åŠŸèƒ½æ˜¯é€’å½’è¯»å–æœ¬åœ°Excelæ–‡ä»¶ï¼ŒæŒ‰ç…§æŒ‡å®šçš„åˆ—åæ˜ å°„è§„åˆ™è¿›è¡Œè½¬æ¢ï¼Œå¹¶ä¸Šä¼ åˆ°æœåŠ¡å™¨ã€‚

### æ ¸å¿ƒåŠŸèƒ½
- ğŸ”„ Excelæ–‡ä»¶æ‰¹é‡å¤„ç†å’Œåˆ—åæ˜ å°„è½¬æ¢
- ğŸ“¤ HTTPæ¥å£æ–‡ä»¶ä¸Šä¼ ï¼ˆæ”¯æŒTokenè®¤è¯ï¼‰
- ğŸ“ ä¿æŒåŸæœ‰ç›®å½•ç»“æ„çš„æ–‡ä»¶ç»„ç»‡
- ğŸ“Š å®æ—¶è¿›åº¦æ˜¾ç¤ºå’Œæ—¥å¿—è®°å½•
- âš¡ æµå¼å¤„ç†æ”¯æŒå¤§æ–‡ä»¶ï¼ˆæ•°ç™¾MBï¼‰

## ğŸ—ï¸ æŠ€æœ¯æ¶æ„

### å‰ç«¯æŠ€æœ¯æ ˆ
- **æ¡†æ¶**: Vue 3.4+ + TypeScript 5.0+
- **æ„å»ºå·¥å…·**: Vite 5.0+
- **UIç»„ä»¶åº“**: Naive UI 2.35+
- **æ ·å¼**: TailwindCSS 3.4+
- **çŠ¶æ€ç®¡ç†**: Pinia 2.1+
- **å›¾æ ‡**: @vicons/ionicons5

### åç«¯æŠ€æœ¯æ ˆ
- **æ¡Œé¢æ¡†æ¶**: Tauri 2.0+
- **è¯­è¨€**: Rust 1.70+
- **Excelå¤„ç†**: calamine 0.24+ (æµå¼è¯»å–)
- **JSONå¤„ç†**: serde 1.0+
- **å¼‚æ­¥è¿è¡Œæ—¶**: tokio 1.0+
- **æ—¥å¿—ç³»ç»Ÿ**: tracing + tracing-subscriber

### é¡¹ç›®ç»“æ„
```
PatentUpload/
â”œâ”€â”€ src/                    # å‰ç«¯æºç 
â”‚   â”œâ”€â”€ components/         # Vueç»„ä»¶
â”‚   â”œâ”€â”€ composables/        # ç»„åˆå¼å‡½æ•°
â”‚   â”œâ”€â”€ stores/            # PiniaçŠ¶æ€ç®¡ç†
â”‚   â”œâ”€â”€ types/             # TypeScriptç±»å‹å®šä¹‰
â”‚   â”œâ”€â”€ utils/             # å·¥å…·å‡½æ•°
â”‚   â””â”€â”€ App.vue            # ä¸»åº”ç”¨ç»„ä»¶
â”œâ”€â”€ src-tauri/             # Tauriåç«¯
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ commands/      # Tauriå‘½ä»¤
â”‚   â”‚   â”œâ”€â”€ utils/         # å·¥å…·å‡½æ•°
â”‚   â”‚   â”œâ”€â”€ excel/         # Excelå¤„ç†æ¨¡å—
â”‚   â”‚   â””â”€â”€ main.rs        # ä¸»ç¨‹åºå…¥å£
â”‚   â”œâ”€â”€ Cargo.toml         # Rustä¾èµ–é…ç½®
â”‚   â””â”€â”€ tauri.conf.json    # Taurié…ç½®
â”œâ”€â”€ doc/                   # é¡¹ç›®æ–‡æ¡£
â””â”€â”€ logs/                  # åº”ç”¨æ—¥å¿—
```

## ğŸ¨ UIè®¾è®¡æ–¹æ¡ˆ

### è®¾è®¡åŸåˆ™
- **ç°ä»£åŒ–**: éµå¾ªç°ä»£æ¡Œé¢åº”ç”¨è®¾è®¡è§„èŒƒ
- **ç®€æ´æ€§**: ç•Œé¢æ¸…æ™°ï¼ŒåŠŸèƒ½åˆ†åŒºæ˜ç¡®
- **æ˜“ç”¨æ€§**: ç›´è§‚çš„æ“ä½œæµç¨‹ï¼Œå‹å¥½çš„é”™è¯¯æç¤º
- **å“åº”å¼**: æ”¯æŒä¸åŒçª—å£å°ºå¯¸çš„è‡ªé€‚åº”å¸ƒå±€

### æ•´ä½“å¸ƒå±€è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    åº”ç”¨æ ‡é¢˜æ                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   é…ç½®é¢æ¿       â”‚           ä¸»æ“ä½œåŒºåŸŸ                  â”‚
â”‚  (å·¦ä¾§ 320px)    â”‚          (ä¸­é—´åŒºåŸŸ)                   â”‚
â”‚                 â”‚                                       â”‚
â”‚ â€¢ æœåŠ¡å™¨é…ç½®     â”‚  â€¢ æ–‡ä»¶å¤¹é€‰æ‹©                         â”‚
â”‚ â€¢ åˆ—åæ˜ å°„é…ç½®   â”‚  â€¢ æ‰«æç»“æœæ˜¾ç¤º                       â”‚
â”‚                 â”‚  â€¢ æ“ä½œæŒ‰é’®ç»„                         â”‚
â”‚                 â”‚  â€¢ è¿›åº¦æ˜¾ç¤º                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   æ—¥å¿—åŒºåŸŸ (åº•éƒ¨ 200px)                  â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### è®¾è®¡è§„èŒƒ
- **è‰²å½©æ–¹æ¡ˆ**: 
  - ä¸»è‰²: #18A058 (æˆåŠŸç»¿)
  - è¾…åŠ©è‰²: #2080F0 (ä¿¡æ¯è“)
  - è­¦å‘Šè‰²: #F0A020 (è­¦å‘Šæ©™)
  - é”™è¯¯è‰²: #D03050 (é”™è¯¯çº¢)
- **é—´è·ç³»ç»Ÿ**: 8pxåŸºå‡†ï¼Œä½¿ç”¨8/16/24/32pxé—´è·
- **åœ†è§’**: 6px (å°ç»„ä»¶) / 8px (å¡ç‰‡) / 12px (å¤§å®¹å™¨)
- **é˜´å½±**: 0 2px 8px rgba(0,0,0,0.1)
- **å­—ä½“**: 
  - æ ‡é¢˜: 16px/18px/20px bold
  - æ­£æ–‡: 14px regular
  - å°å­—: 12px regular

## ğŸ“± è¯¦ç»†ç•Œé¢è®¾è®¡

### 1. é…ç½®é¢æ¿

#### æœåŠ¡å™¨é…ç½®åŒºåŸŸ
```vue
<template>
  <n-card title="æœåŠ¡å™¨é…ç½®" class="mb-4">
    <n-form ref="serverFormRef" :model="serverConfig">
      <n-form-item label="æœåŠ¡å™¨åœ°å€" path="serverUrl">
        <n-input 
          v-model:value="serverConfig.serverUrl" 
          placeholder="https://api.example.com"
          :input-props="{ spellcheck: false }"
        />
      </n-form-item>
      
      <n-form-item label="ç”¨æˆ·å" path="username">
        <n-input 
          v-model:value="serverConfig.username" 
          placeholder="ç”¨æˆ·åæˆ–é‚®ç®±"
        />
      </n-form-item>
      
      <n-form-item label="å¯†ç " path="password">
        <n-input 
          v-model:value="serverConfig.password" 
          type="password" 
          placeholder="ç™»å½•å¯†ç "
          show-password-on="click"
        />
      </n-form-item>
      
      <n-space>
        <n-button 
          @click="testConnection" 
          :loading="testing"
          type="primary"
          size="small"
        >
          æµ‹è¯•è¿æ¥
        </n-button>
        <n-button 
          @click="saveServerConfig"
          type="primary"
          size="small"
        >
          ä¿å­˜é…ç½®
        </n-button>
      </n-space>
      
      <n-alert 
        v-if="connectionStatus" 
        :type="connectionStatus.type"
        :title="connectionStatus.message"
        class="mt-3"
      />
    </n-form>
  </n-card>
</template>
```

#### åˆ—åæ˜ å°„é…ç½®åŒºåŸŸ
```vue
<template>
  <n-card title="åˆ—åæ˜ å°„é…ç½®">
    <n-dynamic-input
      v-model:value="columnMappings"
      :on-create="createMapping"
      #="{ index, value }"
    >
      <n-space align="center">
        <n-input
          v-model:value="value.original"
          placeholder="åŸåˆ—å"
          style="width: 120px"
        />
        <n-text>â†’</n-text>
        <n-input
          v-model:value="value.mapped"
          placeholder="æ–°åˆ—å"
          style="width: 120px"
        />
      </n-space>
    </n-dynamic-input>
    
    <n-space class="mt-4">
      <n-button @click="addMapping" dashed>
        <template #icon>
          <n-icon><Add /></n-icon>
        </template>
        æ·»åŠ æ˜ å°„
      </n-button>
      <n-button @click="importMappings" secondary>
        å¯¼å…¥é…ç½®
      </n-button>
      <n-button @click="exportMappings" secondary>
        å¯¼å‡ºé…ç½®
      </n-button>
    </n-space>
  </n-card>
</template>
```

### 2. ä¸»æ“ä½œåŒºåŸŸ

#### æ–‡ä»¶å¤¹é€‰æ‹©
```vue
<template>
  <n-space vertical size="large">
    <!-- æºæ–‡ä»¶å¤¹é€‰æ‹© -->
    <n-card title="æ–‡ä»¶å¤¹é…ç½®">
      <n-space vertical>
        <n-form-item label="æºæ–‡ä»¶å¤¹">
          <n-input-group>
            <n-input 
              v-model:value="sourcePath" 
              placeholder="é€‰æ‹©åŒ…å«Excelæ–‡ä»¶çš„æ–‡ä»¶å¤¹"
              readonly
            />
            <n-button @click="selectSourceFolder">æµè§ˆ</n-button>
          </n-input-group>
        </n-form-item>
        
        <n-form-item label="ç›®æ ‡æ–‡ä»¶å¤¹">
          <n-input-group>
            <n-input 
              v-model:value="targetPath" 
              placeholder="é€‰æ‹©è½¬æ¢åæ–‡ä»¶çš„ä¿å­˜ä½ç½®"
              readonly
            />
            <n-button @click="selectTargetFolder">æµè§ˆ</n-button>
          </n-input-group>
        </n-form-item>
      </n-space>
    </n-card>

    <!-- æ‰«æç»“æœ -->
    <n-card v-if="scanResult" title="æ‰«æç»“æœ">
      <n-statistic label="å‘ç°Excelæ–‡ä»¶" :value="scanResult.fileCount" />
      <n-statistic label="æ€»å¤§å°" :value="formatFileSize(scanResult.totalSize)" />
      <n-progress 
        v-if="scanResult.progress"
        :percentage="scanResult.progress.percent" 
        :status="scanResult.progress.status"
      />
    </n-card>

    <!-- æ“ä½œæŒ‰é’® -->
    <n-space>
      <n-button 
        @click="scanFiles" 
        :loading="scanning"
        type="primary"
        size="large"
      >
        æ‰«ææ–‡ä»¶
      </n-button>
      <n-button 
        @click="startConversion" 
        :loading="converting"
        :disabled="!canConvert"
        type="warning"
        size="large"
      >
        å¼€å§‹è½¬æ¢
      </n-button>
      <n-button 
        @click="startUpload" 
        :loading="uploading"
        :disabled="!canUpload"
        type="success"
        size="large"
      >
        å¼€å§‹ä¸Šä¼ 
      </n-button>
    </n-space>
  </n-space>
</template>
```

### 3. æ—¥å¿—æ˜¾ç¤ºåŒºåŸŸ

```vue
<template>
  <n-card title="æ“ä½œæ—¥å¿—" class="log-panel">
    <template #header-extra>
      <n-space>
        <n-switch v-model:value="autoScroll">
          <template #checked>è‡ªåŠ¨æ»šåŠ¨</template>
          <template #unchecked>åœæ­¢æ»šåŠ¨</template>
        </n-switch>
        <n-button @click="exportLogs" size="small">
          <template #icon>
            <n-icon><Download /></n-icon>
          </template>
          å¯¼å‡ºæ—¥å¿—
        </n-button>
        <n-button @click="clearLogs" size="small">
          æ¸…ç©ºæ—¥å¿—
        </n-button>
      </n-space>
    </template>

    <div class="log-controls mb-3">
      <n-space>
        <n-radio-group v-model:value="logFilter" size="small">
          <n-radio-button value="all">å…¨éƒ¨</n-radio-button>
          <n-radio-button value="info">ä¿¡æ¯</n-radio-button>
          <n-radio-button value="warn">è­¦å‘Š</n-radio-button>
          <n-radio-button value="error">é”™è¯¯</n-radio-button>
        </n-radio-group>
        <n-input 
          v-model:value="searchKeyword" 
          placeholder="æœç´¢æ—¥å¿—..." 
          clearable
          size="small"
          style="width: 200px"
        />
      </n-space>
    </div>

    <div ref="logContainer" class="log-container">
      <div 
        v-for="log in filteredLogs" 
        :key="log.id"
        :class="['log-entry', `log-${log.level}`]"
      >
        <span class="log-timestamp">{{ formatTime(log.timestamp) }}</span>
        <span class="log-level">{{ log.level.toUpperCase() }}</span>
        <span class="log-message">{{ log.message }}</span>
      </div>
    </div>
  </n-card>
</template>

<style scoped>
.log-container {
  height: 200px;
  overflow-y: auto;
  background: #f8f9fa;
  border-radius: 6px;
  padding: 8px;
  font-family: 'Consolas', 'Monaco', monospace;
  font-size: 12px;
}

.log-entry {
  display: flex;
  margin-bottom: 4px;
  line-height: 1.4;
}

.log-timestamp {
  color: #666;
  margin-right: 8px;
  min-width: 80px;
}

.log-level {
  margin-right: 8px;
  font-weight: bold;
  min-width: 50px;
}

.log-info .log-level { color: #2080f0; }
.log-warn .log-level { color: #f0a020; }
.log-error .log-level { color: #d03050; }
.log-success .log-level { color: #18a058; }

.log-message {
  flex: 1;
  word-break: break-all;
}
</style>
```

## ğŸ”§ æ ¸å¿ƒæŠ€æœ¯å®ç°

### 1. Tauriå‘½ä»¤æ¥å£è®¾è®¡

```rust
// src-tauri/src/commands/mod.rs
use tauri::command;
use std::collections::HashMap;

#[derive(serde::Serialize, serde::Deserialize)]
pub struct ScanResult {
    file_count: usize,
    total_size: u64,
    files: Vec<String>,
}

#[derive(serde::Serialize, serde::Deserialize)]
pub struct ServerConfig {
    server_url: String,
    username: String,
    password: String,
}

#[derive(serde::Serialize, serde::Deserialize)]
pub struct ColumnMapping {
    original: String,
    mapped: String,
}

// æ‰«æExcelæ–‡ä»¶
#[command]
pub async fn scan_excel_files(source_path: String) -> Result<ScanResult, String> {
    excel::scan_directory(&source_path).await
        .map_err(|e| e.to_string())
}

// è½¬æ¢Excelæ–‡ä»¶
#[command]
pub async fn convert_excel_files(
    source_path: String,
    target_path: String,
    mappings: Vec<ColumnMapping>
) -> Result<Vec<String>, String> {
    excel::convert_files(&source_path, &target_path, &mappings).await
        .map_err(|e| e.to_string())
}

// é€‰æ‹©æ–‡ä»¶å¤¹
#[command]
pub async fn select_folder() -> Result<Option<String>, String> {
    use tauri::api::dialog::blocking::FileDialogBuilder;
    
    let folder = FileDialogBuilder::new()
        .set_title("é€‰æ‹©æ–‡ä»¶å¤¹")
        .pick_folder();
        
    Ok(folder.map(|p| p.to_string_lossy().to_string()))
}

// è·å–è½¬æ¢åçš„æ–‡ä»¶åˆ—è¡¨
#[command]
pub async fn get_converted_files(target_path: String) -> Result<Vec<String>, String> {
    excel::get_excel_files(&target_path).await
        .map_err(|e| e.to_string())
}
```

### 2. Excelæµå¼å¤„ç†å®ç°

```rust
// src-tauri/src/excel/mod.rs
use calamine::{Reader, Xlsx, open_workbook, DataType};
use std::collections::HashMap;
use tokio::fs::File;
use tokio::io::AsyncWriteExt;

pub async fn convert_files(
    source_path: &str,
    target_path: &str,
    mappings: &[ColumnMapping]
) -> Result<(), Box<dyn std::error::Error>> {
    let mapping_map: HashMap<String, String> = mappings
        .iter()
        .map(|m| (m.original.clone(), m.mapped.clone()))
        .collect();

    let excel_files = scan_directory(source_path).await?;
    
    for file_path in excel_files.files {
        convert_single_file(&file_path, source_path, target_path, &mapping_map).await?;
    }
    
    Ok(())
}

async fn convert_single_file(
    file_path: &str,
    source_root: &str,
    target_root: &str,
    mappings: &HashMap<String, String>
) -> Result<(), Box<dyn std::error::Error>> {
    // æ‰“å¼€Excelæ–‡ä»¶
    let mut workbook: Xlsx<_> = open_workbook(file_path)?;
    
    // è·å–ç›®æ ‡æ–‡ä»¶è·¯å¾„
    let target_path = get_target_path(file_path, source_root, target_root)?;
    
    // åˆ›å»ºæ–°çš„Excelæ–‡ä»¶
    let mut new_workbook = xlsxwriter::Workbook::new(&target_path)?;
    
    // å¤„ç†æ¯ä¸ªå·¥ä½œè¡¨
    for sheet_name in workbook.sheet_names().to_owned() {
        if let Some(Ok(range)) = workbook.worksheet_range(&sheet_name) {
            let mut worksheet = new_workbook.add_worksheet(Some(&sheet_name))?;
            
            // å¤„ç†è¡¨å¤´
            if let Some(first_row) = range.rows().next() {
                let mapped_headers = map_headers(first_row, mappings);
                
                // å†™å…¥æ˜ å°„åçš„è¡¨å¤´
                for (col, header) in mapped_headers.iter().enumerate() {
                    worksheet.write_string(0, col as u16, header, None)?;
                }
                
                // å†™å…¥æ•°æ®è¡Œï¼ˆæµå¼å¤„ç†ï¼‰
                for (row_idx, row) in range.rows().skip(1).enumerate() {
                    for (col_idx, cell) in row.iter().enumerate() {
                        let value = match cell {
                            DataType::String(s) => s.clone(),
                            DataType::Int(i) => i.to_string(),
                            DataType::Float(f) => f.to_string(),
                            DataType::Bool(b) => b.to_string(),
                            _ => String::new(),
                        };
                        worksheet.write_string(
                            (row_idx + 1) as u32, 
                            col_idx as u16, 
                            &value, 
                            None
                        )?;
                    }
                    
                    // å®šæœŸæ£€æŸ¥æ˜¯å¦éœ€è¦é‡Šæ”¾å†…å­˜
                    if row_idx % 1000 == 0 {
                        tokio::task::yield_now().await;
                    }
                }
            }
        }
    }
    
    new_workbook.close()?;
    Ok(())
}

fn map_headers(
    headers: &[DataType], 
    mappings: &HashMap<String, String>
) -> Vec<String> {
    headers.iter().map(|header| {
        let header_str = match header {
            DataType::String(s) => s.clone(),
            _ => header.to_string(),
        };
        
        mappings.get(&header_str)
            .cloned()
            .unwrap_or(header_str)
    }).collect()
}
```

### 3. å‰ç«¯HTTPä¸Šä¼ å®ç°

```typescript
// src/utils/httpClient.ts
export interface LoginRequest {
  username: string;
  password: string;
}

export interface LoginResponse {
  success: boolean;
  data: {
    id: number;
    username: string;
    token: string;
  };
}

export interface UploadResponse {
  success: boolean;
  data: {
    modifiedCount: number;
    upsertedCount: number;
    excelCount: number;
  };
}

export class HttpClient {
  private baseUrl: string = '';
  private token: string = '';

  setBaseUrl(url: string) {
    this.baseUrl = url.replace(/\/$/, ''); // ç§»é™¤æœ«å°¾æ–œæ 
  }

  async login(username: string, password: string): Promise<LoginResponse> {
    const response = await fetch(`${this.baseUrl}/auth/admin/login`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ username, password }),
    });

    if (!response.ok) {
      throw new Error(`ç™»å½•å¤±è´¥: ${response.status} ${response.statusText}`);
    }

    const result: LoginResponse = await response.json();
    
    if (result.success && result.data?.token) {
      this.token = result.data.token;
      return result;
    } else {
      throw new Error('ç™»å½•å¤±è´¥ï¼šæ— æ•ˆçš„å“åº”æ•°æ®');
    }
  }

  async uploadFile(file: File, onProgress?: (progress: number) => void): Promise<UploadResponse> {
    if (!this.token) {
      throw new Error('è¯·å…ˆç™»å½•');
    }

    return new Promise((resolve, reject) => {
      const formData = new FormData();
      formData.append('file', file);

      const xhr = new XMLHttpRequest();

      // ç›‘å¬ä¸Šä¼ è¿›åº¦
      if (onProgress) {
        xhr.upload.addEventListener('progress', (event) => {
          if (event.lengthComputable) {
            const progress = (event.loaded / event.total) * 100;
            onProgress(Math.round(progress));
          }
        });
      }

      // ç›‘å¬è¯·æ±‚å®Œæˆ
      xhr.addEventListener('load', () => {
        if (xhr.status >= 200 && xhr.status < 300) {
          try {
            const result: UploadResponse = JSON.parse(xhr.responseText);
            resolve(result);
          } catch (error) {
            reject(new Error('è§£æå“åº”æ•°æ®å¤±è´¥'));
          }
        } else {
          reject(new Error(`ä¸Šä¼ å¤±è´¥: ${xhr.status} ${xhr.statusText}`));
        }
      });

      // ç›‘å¬è¯·æ±‚é”™è¯¯
      xhr.addEventListener('error', () => {
        reject(new Error('ç½‘ç»œé”™è¯¯'));
      });

      // ç›‘å¬è¯·æ±‚ä¸­æ–­
      xhr.addEventListener('abort', () => {
        reject(new Error('ä¸Šä¼ è¢«ä¸­æ–­'));
      });

      // è®¾ç½®è¯·æ±‚å¤´å’Œå‘é€è¯·æ±‚
      xhr.open('POST', `${this.baseUrl}/admin/patent/import`);
      xhr.setRequestHeader('Authorization', `Bearer ${this.token}`);
      xhr.send(formData);
    });
  }

  async testConnection(): Promise<boolean> {
    try {
      const response = await fetch(`${this.baseUrl}/auth/admin/login`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ username: 'test', password: 'test' }),
      });
      
      // åªè¦èƒ½æ”¶åˆ°å“åº”å°±è¯´æ˜æœåŠ¡å™¨å¯è¾¾ï¼Œä¸ç®¡æ˜¯å¦ç™»å½•æˆåŠŸ
      return true;
    } catch (error) {
      return false;
    }
  }

  getToken(): string {
    return this.token;
  }

  clearToken() {
    this.token = '';
  }
}

export const httpClient = new HttpClient();
```

### 4. Vueæ–‡ä»¶ä¸Šä¼ ç»„åˆå¼å‡½æ•°

```typescript
// src/composables/useFileUpload.ts
import { ref, computed } from 'vue';
import { httpClient, type UploadResponse } from '@/utils/httpClient';

export interface UploadProgress {
  fileIndex: number;
  fileName: string;
  progress: number; // 0-100
  status: 'pending' | 'uploading' | 'completed' | 'failed';
  error?: string;
  result?: UploadResponse;
}

export function useFileUpload() {
  const uploading = ref(false);
  const uploadQueue = ref<File[]>([]);
  const uploadProgress = ref<UploadProgress[]>([]);
  const currentUploadIndex = ref(-1);

  const overallProgress = computed(() => {
    if (uploadProgress.value.length === 0) return 0;
    
    const totalProgress = uploadProgress.value.reduce((sum, item) => {
      return sum + (item.status === 'completed' ? 100 : item.progress);
    }, 0);
    
    return Math.round(totalProgress / uploadProgress.value.length);
  });

  const completedCount = computed(() => {
    return uploadProgress.value.filter(item => item.status === 'completed').length;
  });

  const failedCount = computed(() => {
    return uploadProgress.value.filter(item => item.status === 'failed').length;
  });

  function initializeUpload(files: File[]) {
    uploadQueue.value = [...files];
    uploadProgress.value = files.map((file, index) => ({
      fileIndex: index,
      fileName: file.name,
      progress: 0,
      status: 'pending',
    }));
    currentUploadIndex.value = -1;
  }

  async function startUpload(): Promise<void> {
    if (uploadQueue.value.length === 0) return;
    
    uploading.value = true;
    currentUploadIndex.value = 0;

    try {
      // é€ä¸ªä¸Šä¼ æ–‡ä»¶
      for (let i = 0; i < uploadQueue.value.length; i++) {
        currentUploadIndex.value = i;
        await uploadSingleFile(i);
        
        // é¿å…æœåŠ¡å™¨è¿‡è½½ï¼Œæ¯æ¬¡ä¸Šä¼ åç¨ä½œæš‚åœ
        if (i < uploadQueue.value.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 500));
        }
      }
    } finally {
      uploading.value = false;
      currentUploadIndex.value = -1;
    }
  }

  async function uploadSingleFile(index: number): Promise<void> {
    const file = uploadQueue.value[index];
    const progressItem = uploadProgress.value[index];

    progressItem.status = 'uploading';
    progressItem.progress = 0;
    progressItem.error = undefined;

    try {
      const result = await httpClient.uploadFile(file, (progress) => {
        progressItem.progress = progress;
      });

      progressItem.status = 'completed';
      progressItem.progress = 100;
      progressItem.result = result;
      
    } catch (error) {
      progressItem.status = 'failed';
      progressItem.error = error instanceof Error ? error.message : 'ä¸Šä¼ å¤±è´¥';
      throw error;
    }
  }

  async function retryUpload(index: number): Promise<void> {
    if (index < 0 || index >= uploadQueue.value.length) return;
    
    const progressItem = uploadProgress.value[index];
    if (progressItem.status !== 'failed') return;

    try {
      await uploadSingleFile(index);
    } catch (error) {
      console.error(`é‡è¯•ä¸Šä¼ æ–‡ä»¶ ${progressItem.fileName} å¤±è´¥:`, error);
    }
  }

  function clearUploadHistory() {
    uploadQueue.value = [];
    uploadProgress.value = [];
    currentUploadIndex.value = -1;
  }

  return {
    uploading: readonly(uploading),
    uploadProgress: readonly(uploadProgress),
    currentUploadIndex: readonly(currentUploadIndex),
    overallProgress,
    completedCount,
    failedCount,
    initializeUpload,
    startUpload,
    retryUpload,
    clearUploadHistory,
  };
}
```

### 5. å¢å¼ºçš„ä¸Šä¼ ç•Œé¢ç»„ä»¶

```vue
<template>
  <n-card title="æ–‡ä»¶ä¸Šä¼ ">
    <!-- ç™»å½•çŠ¶æ€ -->
    <n-alert 
      v-if="!isLoggedIn" 
      type="warning" 
      title="è¯·å…ˆé…ç½®æœåŠ¡å™¨ä¿¡æ¯å¹¶ç™»å½•"
      class="mb-4"
    />
    
    <!-- æ•´ä½“è¿›åº¦ -->
    <div v-if="uploadProgress.length > 0" class="mb-4">
      <div class="flex justify-between items-center mb-2">
        <n-text strong>ä¸Šä¼ è¿›åº¦</n-text>
        <n-text depth="3">
          {{ completedCount }}/{{ uploadProgress.length }} å·²å®Œæˆ
          <span v-if="failedCount > 0" class="text-red-500">
            ({{ failedCount }} å¤±è´¥)
          </span>
        </n-text>
      </div>
      <n-progress 
        :percentage="overallProgress" 
        :status="failedCount > 0 ? 'error' : 'success'"
      />
    </div>
    
    <!-- æ–‡ä»¶åˆ—è¡¨ -->
    <n-list v-if="uploadProgress.length > 0" class="mb-4">
      <n-list-item 
        v-for="(file, index) in uploadProgress" 
        :key="index"
      >
        <n-thing :title="file.fileName">
          <template #description>
            <n-space align="center" class="mt-2">
              <n-progress 
                :percentage="file.progress" 
                :status="getProgressStatus(file.status)"
                style="width: 200px"
                :show-indicator="false"
              />
              <n-tag 
                :type="getStatusTagType(file.status)"
                size="small"
              >
                {{ getStatusText(file.status) }}
              </n-tag>
              <n-text v-if="file.error" type="error" depth="3">
                {{ file.error }}
              </n-text>
              <n-text v-if="file.result?.success" type="success" depth="3">
                å¯¼å…¥ {{ file.result.data.excelCount }} ä¸ªæ–‡ä»¶
              </n-text>
            </n-space>
          </template>
          
          <template #action>
            <n-button 
              v-if="file.status === 'failed'"
              @click="retryUpload(index)"
              size="small"
              type="primary"
              secondary
            >
              é‡è¯•
            </n-button>
          </template>
        </n-thing>
      </n-list-item>
    </n-list>
    
    <!-- æ§åˆ¶æŒ‰é’® -->
    <n-space>
      <n-button 
        @click="handleStartUpload" 
        :loading="uploading"
        :disabled="!canUpload"
        type="primary"
        size="large"
      >
        <template #icon>
          <n-icon><CloudUpload /></n-icon>
        </template>
        å¼€å§‹ä¸Šä¼  ({{ convertedFiles.length }} ä¸ªæ–‡ä»¶)
      </n-button>
      
      <n-button 
        v-if="uploadProgress.length > 0"
        @click="clearUploadHistory"
        :disabled="uploading"
        secondary
      >
        æ¸…ç©ºè®°å½•
      </n-button>
    </n-space>
  </n-card>
</template>

<script setup lang="ts">
import { computed, ref } from 'vue';
import { useMessage } from 'naive-ui';
import { CloudUpload } from '@vicons/ionicons5';
import { useFileUpload } from '@/composables/useFileUpload';
import { httpClient } from '@/utils/httpClient';

interface Props {
  convertedFiles: File[];
  serverConfig: {
    serverUrl: string;
    username: string;
    password: string;
  };
}

const props = defineProps<Props>();
const message = useMessage();

const {
  uploading,
  uploadProgress,
  overallProgress,
  completedCount,
  failedCount,
  initializeUpload,
  startUpload,
  retryUpload,
  clearUploadHistory,
} = useFileUpload();

const isLoggedIn = computed(() => {
  return !!httpClient.getToken() && 
         props.serverConfig.serverUrl && 
         props.serverConfig.username;
});

const canUpload = computed(() => {
  return isLoggedIn.value && 
         props.convertedFiles.length > 0 && 
         !uploading.value;
});

async function handleStartUpload() {
  if (!canUpload.value) return;

  try {
    // å¦‚æœæ²¡æœ‰tokenï¼Œå…ˆç™»å½•
    if (!httpClient.getToken()) {
      httpClient.setBaseUrl(props.serverConfig.serverUrl);
      await httpClient.login(
        props.serverConfig.username, 
        props.serverConfig.password
      );
      message.success('ç™»å½•æˆåŠŸ');
    }

    // åˆå§‹åŒ–ä¸Šä¼ é˜Ÿåˆ—
    initializeUpload(props.convertedFiles);
    
    // å¼€å§‹ä¸Šä¼ 
    await startUpload();
    
    if (failedCount.value === 0) {
      message.success(`æ‰€æœ‰æ–‡ä»¶ä¸Šä¼ å®Œæˆ! å…± ${completedCount.value} ä¸ªæ–‡ä»¶`);
    } else {
      message.warning(`ä¸Šä¼ å®Œæˆï¼Œ${completedCount.value} æˆåŠŸï¼Œ${failedCount.value} å¤±è´¥`);
    }
    
  } catch (error) {
    console.error('ä¸Šä¼ è¿‡ç¨‹å‡ºé”™:', error);
    message.error(error instanceof Error ? error.message : 'ä¸Šä¼ å¤±è´¥');
  }
}

function getProgressStatus(status: string) {
  switch (status) {
    case 'completed': return 'success';
    case 'failed': return 'error';
    case 'uploading': return 'info';
    default: return 'default';
  }
}

function getStatusTagType(status: string) {
  switch (status) {
    case 'completed': return 'success';
    case 'failed': return 'error';
    case 'uploading': return 'info';
    default: return 'default';
  }
}

function getStatusText(status: string) {
  switch (status) {
    case 'pending': return 'ç­‰å¾…ä¸­';
    case 'uploading': return 'ä¸Šä¼ ä¸­';
    case 'completed': return 'å·²å®Œæˆ';
    case 'failed': return 'å¤±è´¥';
    default: return 'æœªçŸ¥';
  }
}
</script>
```
```

### 4. Vueç»„åˆå¼å‡½æ•° - æ–‡ä»¶æ“ä½œ

```typescript
// src/composables/useFileOperations.ts
import { ref, computed } from 'vue'
import { invoke } from '@tauri-apps/api/tauri'
import { open } from '@tauri-apps/api/dialog'

export interface ScanResult {
  fileCount: number
  totalSize: number
  files: string[]
}

export interface ColumnMapping {
  original: string
  mapped: string
}

export function useFileOperations() {
  const sourcePath = ref('')
  const targetPath = ref('')
  const scanResult = ref<ScanResult | null>(null)
  const convertedFiles = ref<File[]>([])
  const scanning = ref(false)
  const converting = ref(false)
  
  const canConvert = computed(() => 
    scanResult.value && scanResult.value.fileCount > 0 && targetPath.value
  )
  
  const canUpload = computed(() => 
    convertedFiles.value.length > 0
  )
  
  async function selectSourceFolder() {
    try {
      const selected = await open({
        directory: true,
        title: 'é€‰æ‹©æºæ–‡ä»¶å¤¹'
      })
      if (selected) {
        sourcePath.value = selected as string
      }
    } catch (error) {
      console.error('é€‰æ‹©æ–‡ä»¶å¤¹å¤±è´¥:', error)
    }
  }
  
  async function selectTargetFolder() {
    try {
      const selected = await open({
        directory: true,
        title: 'é€‰æ‹©ç›®æ ‡æ–‡ä»¶å¤¹'
      })
      if (selected) {
        targetPath.value = selected as string
      }
    } catch (error) {
      console.error('é€‰æ‹©æ–‡ä»¶å¤¹å¤±è´¥:', error)
    }
  }
  
  async function scanFiles() {
    if (!sourcePath.value) return
    
    scanning.value = true
    try {
      const result = await invoke('scan_excel_files', {
        sourcePath: sourcePath.value
      })
      scanResult.value = result as ScanResult
    } catch (error) {
      console.error('æ‰«ææ–‡ä»¶å¤±è´¥:', error)
      throw error
    } finally {
      scanning.value = false
    }
  }
  
  async function startConversion(mappings: ColumnMapping[]) {
    if (!canConvert.value) return
    
    converting.value = true
    try {
      const convertedFilePaths = await invoke('convert_excel_files', {
        sourcePath: sourcePath.value,
        targetPath: targetPath.value,
        mappings
      }) as string[]
      
      // å°†æ–‡ä»¶è·¯å¾„è½¬æ¢ä¸ºFileå¯¹è±¡
      const files = await Promise.all(
        convertedFilePaths.map(async (filePath) => {
          const response = await fetch(`file://${filePath}`)
          const blob = await response.blob()
          const fileName = filePath.split('/').pop() || 'unknown.xlsx'
          return new File([blob], fileName, { 
            type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' 
          })
        })
      )
      
      convertedFiles.value = files
      return files
    } catch (error) {
      console.error('è½¬æ¢æ–‡ä»¶å¤±è´¥:', error)
      throw error
    } finally {
      converting.value = false
    }
  }
  
  function clearConvertedFiles() {
    convertedFiles.value = []
  }
  
  return {
    sourcePath,
    targetPath,
    scanResult,
    convertedFiles: readonly(convertedFiles),
    scanning: readonly(scanning),
    converting: readonly(converting),
    canConvert,
    canUpload,
    selectSourceFolder,
    selectTargetFolder,
    scanFiles,
    startConversion,
    clearConvertedFiles
  }
}
```

## ğŸ“¦ ä¾èµ–é…ç½®

### å‰ç«¯ä¾èµ– (package.json)
```json
{
  "dependencies": {
    "vue": "^3.4.0",
    "naive-ui": "^2.35.0",
    "pinia": "^2.1.0",
    "@tauri-apps/api": "^2.0.0",
    "@vicons/ionicons5": "^0.12.0"
  },
  "devDependencies": {
    "typescript": "^5.0.0",
    "vite": "^5.0.0",
    "@vitejs/plugin-vue": "^5.0.0",
    "tailwindcss": "^3.4.0",
    "@types/node": "^20.0.0"
  }
}
```

### åç«¯ä¾èµ– (Cargo.toml)
```toml
[dependencies]
tauri = { version = "2.0", features = ["protocol-asset", "dialog-open"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tokio = { version = "1.0", features = ["full"] }
calamine = { version = "0.24", features = ["dates"] }
xlsxwriter = "0.6"
walkdir = "2.4"
tracing = "0.1"
tracing-subscriber = "0.3"
chrono = { version = "0.4", features = ["serde"] }
uuid = { version = "1.0", features = ["v4"] }
anyhow = "1.0"
```

## ğŸš€ å¼€å‘æµç¨‹

### ç¯å¢ƒæ­å»º
1. å®‰è£… Rust (rustup)
2. å®‰è£… Node.js 18+
3. å®‰è£… pnpm
4. å…‹éš†é¡¹ç›®å¹¶å®‰è£…ä¾èµ–

### å¼€å‘å‘½ä»¤
```bash
# å®‰è£…ä¾èµ–
pnpm install

# å¼€å‘æ¨¡å¼
pnpm tauri dev

# æ„å»ºåº”ç”¨
pnpm tauri build

# ç±»å‹æ£€æŸ¥
pnpm vue-tsc --noEmit

# ä»£ç æ ¼å¼åŒ–
pnpm prettier --write src/
```

### æ„å»ºé…ç½®
- æ”¯æŒ Windowsã€macOSã€Linux ä¸‰å¹³å°
- è‡ªåŠ¨ç­¾åå’Œå…¬è¯ (macOS)
- åº”ç”¨å›¾æ ‡å’Œå…ƒæ•°æ®é…ç½®
- å®‰è£…åŒ…ç”Ÿæˆ

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### Excelå¤„ç†ä¼˜åŒ–
- æµå¼è¯»å–ï¼Œåˆ†æ‰¹å¤„ç†æ•°æ®
- å†…å­˜ä½¿ç”¨ç›‘æ§å’Œé‡Šæ”¾
- å¤§æ–‡ä»¶å¼‚æ­¥å¤„ç†
- é”™è¯¯æ¢å¤æœºåˆ¶

### UIå“åº”æ€§ä¼˜åŒ–
- è™šæ‹Ÿæ»šåŠ¨ï¼ˆæ—¥å¿—æ˜¾ç¤ºï¼‰
- é˜²æŠ–è¾“å…¥å¤„ç†
- å¼‚æ­¥ä»»åŠ¡è¿›åº¦åé¦ˆ
- ç»„ä»¶æ‡’åŠ è½½

### ç½‘ç»œä¸Šä¼ ä¼˜åŒ–
- è¯·æ±‚é‡è¯•æœºåˆ¶
- ä¸Šä¼ è¿›åº¦ç›‘æ§
- æ–‡ä»¶åˆ†ç‰‡ä¸Šä¼ æ”¯æŒ
- å¹¶å‘ä¸Šä¼ æ§åˆ¶

## ğŸ”’ å®‰å…¨è€ƒè™‘

### æ•°æ®å®‰å…¨
- å¯†ç æœ¬åœ°åŠ å¯†å­˜å‚¨
- Tokenå†…å­˜ç®¡ç†ï¼Œåº”ç”¨å…³é—­æ—¶æ¸…ç†
- æ–‡ä»¶è®¿é—®æƒé™æ§åˆ¶
- æ•æ„Ÿä¿¡æ¯è„±æ•

### ç½‘ç»œå®‰å…¨
- HTTPSå¼ºåˆ¶ä½¿ç”¨
- JWT Tokenè®¤è¯
- é˜²æ­¢CSRFæ”»å‡»
- è¾“å…¥éªŒè¯å’Œæ¸…ç†

## ğŸ“ˆ æ‰©å±•æ€§è®¾è®¡

### æ’ä»¶æ¶æ„
- åˆ—åæ˜ å°„è§„åˆ™æ’ä»¶åŒ–
- æ–‡ä»¶æ ¼å¼æ‰©å±•æ”¯æŒ
- è‡ªå®šä¹‰ä¸Šä¼ é€»è¾‘
- ç¬¬ä¸‰æ–¹æœåŠ¡é›†æˆ

### é…ç½®ç®¡ç†
- å¤šç¯å¢ƒé…ç½®
- ç”¨æˆ·åå¥½è®¾ç½®
- æ¨¡æ¿å’Œé¢„è®¾
- é…ç½®å¯¼å…¥å¯¼å‡º

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### å•å…ƒæµ‹è¯•
- Rustä¸šåŠ¡é€»è¾‘æµ‹è¯•
- Vueç»„ä»¶æµ‹è¯•
- HTTPå®¢æˆ·ç«¯æµ‹è¯•
- å·¥å…·å‡½æ•°æµ‹è¯•

### é›†æˆæµ‹è¯•
- Excelå¤„ç†æµç¨‹æµ‹è¯•
- å‰ç«¯ä¸Šä¼ åŠŸèƒ½æµ‹è¯•
- æ–‡ä»¶ç³»ç»Ÿæ“ä½œæµ‹è¯•

### ç«¯åˆ°ç«¯æµ‹è¯•
- å®Œæ•´å·¥ä½œæµç¨‹æµ‹è¯•
- æ€§èƒ½åŸºå‡†æµ‹è¯•
- å…¼å®¹æ€§æµ‹è¯•

---

## ğŸ“ æ¶æ„å˜æ›´æ€»ç»“

### ä¸»è¦å˜æ›´
1. **HTTPè°ƒç”¨è¿ç§»åˆ°å‰ç«¯** - ç§»é™¤Rustä¾§çš„reqwestä¾èµ–ï¼Œæ”¹ç”¨å‰ç«¯fetch API
2. **æ¥å£é€‚é…** - æ ¹æ®å®é™…APIè°ƒæ•´ç™»å½•å’Œä¸Šä¼ æ¥å£çš„æ•°æ®æ ¼å¼
3. **æ–‡ä»¶å¤„ç†ä¼˜åŒ–** - Rustä¸“æ³¨äºExcelè½¬æ¢ï¼Œå‰ç«¯è´Ÿè´£æ–‡ä»¶ä¸Šä¼ 
4. **è¿›åº¦ç›‘æ§å¢å¼º** - åˆ©ç”¨XMLHttpRequestæä¾›ç²¾ç¡®çš„ä¸Šä¼ è¿›åº¦åé¦ˆ

### ä¼˜åŠ¿
- **èŒè´£åˆ†ç¦»æ›´æ¸…æ™°** - åç«¯ä¸“æ³¨æ–‡ä»¶å¤„ç†ï¼Œå‰ç«¯è´Ÿè´£ç½‘ç»œäº¤äº’
- **ç”¨æˆ·ä½“éªŒæ›´å¥½** - å®æ—¶ä¸Šä¼ è¿›åº¦ã€é‡è¯•æœºåˆ¶ã€é”™è¯¯å¤„ç†
- **å¼€å‘æ•ˆç‡æ›´é«˜** - å‰ç«¯HTTPè°ƒç”¨æ›´çµæ´»ï¼Œè°ƒè¯•æ›´æ–¹ä¾¿
- **ç»´æŠ¤æˆæœ¬æ›´ä½** - å‡å°‘äº†è·¨è¯­è¨€çš„æ•°æ®ä¼ é€’å¤æ‚åº¦

æœ¬è®¾è®¡æ–¹æ¡ˆæä¾›äº†ä¸“åˆ©æ–‡ä»¶ä¸Šä¼ æ¡Œé¢åº”ç”¨çš„å®Œæ•´æŠ€æœ¯æ¶æ„å’Œå®ç°ç»†èŠ‚ï¼Œç¡®ä¿åº”ç”¨çš„åŠŸèƒ½å®Œæ•´æ€§ã€æ€§èƒ½ä¼˜åŒ–å’Œç”¨æˆ·ä½“éªŒã€‚é€šè¿‡æ¨¡å—åŒ–è®¾è®¡å’Œç°ä»£åŒ–æŠ€æœ¯æ ˆï¼Œé¡¹ç›®å…·å¤‡è‰¯å¥½çš„å¯ç»´æŠ¤æ€§å’Œæ‰©å±•æ€§ã€‚